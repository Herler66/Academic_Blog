# Evaluating the Effectiveness of Memory Safety Sanitizers



> 评估内存安全检测工具的有效性
>
> 作者：Emanuel Q. Vintila，Philipp Zieris，Julian Horsch
>
> 单位：Technical University of Munich，Fraunhofer AISEC
>
> 期刊：S&P 2025
>
> 论文链接：[Evaluating the Effectiveness of Memory Safety Sanitizers](https://publica-rest.fraunhofer.de/server/api/core/bitstreams/4400cfa7-fa25-4ac5-b95e-0c4485c88f99/content)

| Recorder | Date      | Categories                          |
| -------- | --------- | ----------------------------------- |
| 林志伟   | 2025-1-10 | Testing, Security，Dynamic Analysis |



## 1. Background

- 现如今存在的内存安全 sanitizers 虽然有着**概念性分类**，但实际的和定量的评估主要关注的是它们的性能，而**不是它们实际发现漏洞的能力**。
  - 概念分类是指根据 sanitizers 的设计原理、检测机制和理论上的功能范围对它们进行分类，侧重于理论上能够检测到哪些类型的内存错误。
  - 实际和定量评估则是指在真实或模拟的环境中对 sanitizers 进行测试，以测量它们在实际应用中的表现。

- 很多内存安全 sanitizer 通常使用测试套件进行功能性检测，例如 Juliet Test Suite，但是这样存在两个问题：
  - 这类测试套件旨在评估静态分析器正确解释程序代码的能力，因此它的测试用例被复制以提供各种控制流和数据流变体，导致相同的内存错误重复出现，这样相关的内存安全 sanitizer 就会有很高的检测率。
  - 大多数漏洞与内存安全无关，测试过程中会倾向于选择相关测试用例的子集，测试套件的高度可变性导致不同的 sanitizer 的可比性比较低。

- 如果一个 sanitizer 在性能上表现很好，但在实际中不能有效地发现漏洞，那么它的实用价值就会大打折扣，因此论文强调需要对 sanitizers 的实际漏洞发现能力进行更深入和全面的评估，而不仅仅是关注其性能表现。
  - 在评估内存安全 sanitizers 时，需要超越仅仅基于概念的分类和性能评估，更加关注它们在实际应用中发现漏洞的能力。
  - 社区尚未建立一个广泛接受且用户友好的指标来评估 sanitizers 的质量，论文实现了测试工具 MSET 来评估不同 sanitizer 的有效性。





## 2. introduction

### 2.1 sanitizer

动态程序分析工具可以分为两类：基于位置（location-based）和基于身份（identity-based）的sanitizers。

基于位置的 sanitizers 使用红区和隔离区来检测内存越界访问，比如 ASan；

而基于身份的 sanitizers 通过维护对象的边界信息来检测内存错误，比如 HWASAN。

但是这些工具在功能测试的过程中都存在着上面提到的问题，论文的实验结果也证实了**所有进行测试的 sanitizer 在实践中都无法提供完整的内存安全性保证**，这也表现了仅仅依靠概念评估可能会忽视实际的实施挑战。

<img src="https://cdn.jsdelivr.net/gh/KylinLzw/MarkdownImage/img/image-20250116234819526.png" alt="image-20250116234819526" style="zoom: 80%;" />    <img src="https://cdn.jsdelivr.net/gh/KylinLzw/MarkdownImage/img/image-20250116234840387.png" alt="image-20250116234840387" style="zoom:80%;" />



### 2.2 内存错误

内存安全错误可以分为空间内存错误和时间内存错误：

- 空间内存错误是指程序访问了分配给对象的内存区域之外的内存；
- 时间内存错误是指程序访问了已释放的内存或错误分配的内存。



#### 2.2.1 空间内存错误：

- **线性越界访问（Linear OOBA）：**
  - 连续内存区域的越界访问，例如缓冲区溢出。
- **非线性越界访问（Non-linear OOBA）**：
  - 通过指针偏移直接访问另一个对象的内存。
- **类型混淆越界访问（Type confusion OOBA）**：
  - 通过类型转换导致的越界访问。



#### 2.2.2 时间内存错误

- **Use-after-\*错误**：
  - 访问已释放的堆对象（use-after-free）、栈对象（use-after-return）或超出作用域的对象（use-after-scope）。
- **Double-free错误**：
  - 对同一个指针调用两次 free。
- **Misuse-of-free错误**：
  - 释放未由 malloc 返回的指针。



## 3. Design

### 3.1 内存错误分类体系：

为了有效地评估和比较 sanitizers 的功能，识别所有相关的内存错误并对它们的各种形式进行分类至关重要，因此**论文提出了一个新的内存错误分类体系，这个体系比现有的分类（如CWE）更精确，能够更细致地区分不同类型的内存错误。**

主要包括：内存错误分类、测试用例原语。



#### 3.1.1 内存错误分类

**空间内存错误分类：**

![image-20250117101259692](https://cdn.jsdelivr.net/gh/KylinLzw/MarkdownImage/img/image-20250117101259692.png)

**时间内存错误：**

![image-20250117102242825](https://cdn.jsdelivr.net/gh/KylinLzw/MarkdownImage/img/image-20250117102242825.png)

#### 3.1.2 测试用例原语：

论文为了将内存错误分类法转化为具体的评估工具，将内存错误解构为三个基本属性：易受攻击的对象所在的内存区域、导致内存损坏的错误类型以及对该对象的访问类型。

对于每个属性定义了不同的原语，从中可以形成实际的内存损坏以及生成测试用例。

![image-20250117102658773](https://cdn.jsdelivr.net/gh/KylinLzw/MarkdownImage/img/image-20250117102658773.png)



​	

### 3.2 MSET

根据上述的评估方法，开发了 Memory Sanitizer Evaluation Tool (MSET)，该工具结合了内存区域、错误类型和访问类型原语来创建小型、独立的 C 程序作为测试用例。 MSET 对每个正在评估的 sanitizers 编译这些测试用例，按顺序执行它们并根据其退出状态评估其结果。

- MSET 基于原语生成了 232 个基本的测试用例，每个测试用例包含特定的内存错误类型，访问特定的目标对象。

- 总的测试用例为 820 个，这些测试用例不仅包括基本的测试用例，还包括多个变体，这些变体通过改变内存布局、对象顺序、辅助变量的放置等参数，生成不同的测试场景，保证在不同的编译环境和内存布局下都能成功触发错误。
- 因此测试用例包括无错误版本（用于保证程序正常执行）、多个变体测试用例（不同的内存布局和运行条件下都能有效触发内存错误）。



#### 3.2.1 测试用例生成

**原语模板**

创建了 232 个独特的测试用例，旨在包含故意的内存错误。为了实现这一点，MSET 为所有原语提供了一套模板，并将它们组合起来形成测试用例。

模板定义了测试用例的基本结构和逻辑，通过填充不同的参数和值，可以生成多种不同的测试用例，这些模板确保了测试用例的一致性和系统性，同时提供了足够的灵活性来覆盖各种内存错误场景。
****
![image-20250117105235379](https://cdn.jsdelivr.net/gh/KylinLzw/MarkdownImage/img/image-20250117105235379.png)   ![image-20250117105315625](https://cdn.jsdelivr.net/gh/KylinLzw/MarkdownImage/img/image-20250117105315625.png)

![image-20250117105247487](https://cdn.jsdelivr.net/gh/KylinLzw/MarkdownImage/img/image-20250117105247487.png)  ![image-20250117105436581](https://cdn.jsdelivr.net/gh/KylinLzw/MarkdownImage/img/image-20250117105436581.png)
****



**无错误版本：**

MSET 首先生成每个测试用例的无错误版本，确保 sanitizer 在没有内存错误的情况下不会引发错误（即不会产生假阳性）。

如果无错误版本运行成功，MSET才会继续执行实际的测试用例。



**变体版本：**

为了确保测试用例在不同的内存布局和运行条件下都能有效触发内存错误，MSET 引入了测试用例变体。

这些变体通过改变内存布局、对象顺序、辅助变量的放置等参数，生成不同的测试场景，变体是确保 MSET 稳健性及其评估结果可比性的重要工具。例如：

- **变体1**：目标对象在堆的开头，起源对象在堆的中间。
- **变体2**：目标对象在堆的中间，起源对象在堆的末尾。
- **变体3**：目标对象在栈的顶部，起源对象在栈的底部。



#### 3.2.2 执行测试用例

1. MSET 逐一执记录消毒行测试用例，并程序是否成功检测到每个测试用例的内存损坏。
2. 如果成功触发测试用例的内存错误，则测试用例返回成功状态，表明清理程序未能检测到内存损坏；如果清理程序检测到内存损坏，测试用例将返回错误状态或引发分段错误。
3. 对于具有多个变体的测试用例，仅当所有测试用例变体均不成功（这意味着它们都没有返回成功状态）时，MSET 才会认为检测到相应的内存错误。
4. MSET 通过执行所有测试用例，生成详细的评估结果。这些结果包括每个测试用例的检测率，以及sanitizer在不同错误类型上的表现。
5. 具体评估结果通过六维雷达图展示，每个轴代表一种错误类型的成功缓解百分比，这些结果帮助评估sanitizer的实际效果，揭示其在不同场景下的表现。



## 4. Elevation

1. 为了确保 232 个测试用例结果的可比性，论文根据六种错误类型对它们进行分类：线性、非线性和类型混淆 OOBA，以及 use-after-*、双重释放和误用释放错误。
2. 分别报告和讨论六种错误类型中每种错误类型的结果，因为将它们总结为总体分数容易产生偏差。为了可视化结果，论文中采用6维雷达图，每个轴代表针对相应错误类型成功缓解的测试用例的百分比（本质上是错误检测率），因此，每个轴都包含该 bug 类型的所有可能的原语组合。
3. 每个结果图包括理论潜力、实际表现、程序基准。

![image-20250117110931661](https://cdn.jsdelivr.net/gh/KylinLzw/MarkdownImage/img/image-20250117110931661.png)



#### ASan：

- 空间安全：
  - 线性越界访问：**77.7%（理论潜力80%）**
  - 类型混淆越界访问：**60%（理论潜力80%）**
  - 非线性越界访问：未提供具体数据
- 时间安全：
  - Use-after-\* 错误：**50%（理论潜力50%）**
  - Double-free 错误：**100%**
  - Misuse-of-free 错误：**0%（理论潜力50%）**

ASan 在空间安全方面表现良好，但仍有改进空间。ASan 使用红区来检测线性越界访问，但无法检测非线性越界访问和对象内部的越界访问。

在时间安全方面，ASan 能够检测到所有 double-free 错误，但在 use-after-* 错误和 misuse-of-free 错误上的表现不佳。这表明 ASan 在处理已释放内存的检测上存在不足。



#### HWASAN：

- 空间安全：
  - 线性越界访问：**71.8%（理论潜力80%）**
  - 类型混淆越界访问：**24%（理论潜力80%）**
  - 非线性越界访问：**53.9%**
- 时间安全：
  - Use-after-\* 错误：**100%**
  - Double-free 错误：**100%**
  - Misuse-of-free 错误：**60%**

HWASAN 在空间安全方面表现良好，特别是在线性越界访问上的检测率较高。然而，其在类型混淆越界访问上的检测率较低，这表明其在处理复杂类型转换时存在不足。

在时间安全方面，HWASAN 表现优异，能够检测到所有时间内存错误。这表明其在处理已释放内存的检测上非常有效。



#### 结果分析：

- 评估结果显示，尽管一些 sanitizer 实现了其全部概念检测潜力，但大多数实际应用中都未能实现。
  - 这通常是由于实施不完整或正确应用检测技术时出现错误所致；
  - 部分工具优先考虑性能或兼容性，从而阻止它们发挥其概念潜力；
  - 还有就是一些 sanitizers 受到硬件限制，无法实现更高的检测率。

- 结果也表明仅仅依靠概念评估会忽视实际的实施挑战，并导致实践中sanitizers的效果较差。
- 未来的 sanitizers 研究应侧重于实施更完整的检测概念并进行彻底的功能评估，以确保 sanitizer 充分发挥其概念潜力。



## 5. Idea

#### 创新点：

1、论文提出了一个新的内存错误分类体系，将内存错误分为空间内存错误和时间内存错误，并进一步细分为具体的错误类型，这个分类体系比现有的分类（如CWE）更精确，能够更细致地区分不同类型的内存错误。

2、在此基础上开发了一个名为 MSET 的工具，用于生成系统化的测试用例，MSET 通过组合不同的原语生成 232 个独特的测试用例，并为每个测试用例生成多个变体，确保在不同的内存布局和运行条件下都能有效触发内存错误。

3、测试过程中使用了变体测试样例保证测试的完备性和准确性，对测试结果也进行了细致的展示和可视化，整个工具链都有很完整的流程和保障。



#### 观察点：

ASan 由于发展比较完善，近几年没有大的突破和进展，更多是进行性能的优化和特定场景下的版本设计。

而像 HWASAN 这类基于身份识别的 sanitizer 由于其准确性和硬件水平的提高，近几年出现了更多的新工具。

![image-20250117094948888](https://cdn.jsdelivr.net/gh/KylinLzw/MarkdownImage/img/image-20250117094948888.png)

![image-20250117095043015](https://cdn.jsdelivr.net/gh/KylinLzw/MarkdownImage/img/image-20250117095043015.png)



论文结果证实了在 sanitizer 开发中进行功能测试的必要性，因为仅仅依靠概念评估可能会忽视实际的实施挑战，从而导致 sanitizers 的效果较差。

未来的 sanitizers 研究应侧重于实施更完整的检测概念并进行彻底的功能评估，以确保 sanitizers 充分发挥其概念潜力。

![image-20250117114547120](https://cdn.jsdelivr.net/gh/KylinLzw/MarkdownImage/img/image-20250117114547120.png)



