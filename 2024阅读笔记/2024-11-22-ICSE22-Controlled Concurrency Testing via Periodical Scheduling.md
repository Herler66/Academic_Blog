# Controlled Concurrency Testing via Periodical Scheduling

>PERIOD：受控并发测试
>
>作者：Cheng Wen, Mengda He, Bohao Wu, Zhiwu Xu and Shengchao Qin
>
>单位：Shenzhen University, Huawei
>
>会议：ICSE 2022
>
>论文链接： [Controlled Concurrency Testing via Periodical Scheduling](https://wcventure.github.io/pdf/ICSE2022_PERIOD.pdf)

|Recorder|Date|Categories|
|----|----|----|
|黄俊杰|2024-11-22|Testing, Concurrency Program|

-----

为了充分利用当前现代多处理器硬件的计算能力，并行程序已经广泛流行。但是和顺序执行不一样，并行程序不仅受到输入的影响，还会受到多个线程交错运行顺序的影响,从而使得并发错误有了更多的可能性。

检测数据竞争是一种广泛的查找并发错误的方法，数据竞争通常是被广泛认为并发错误的原因，但是无竞争的并行程序也会有可能并发错误。

![image-20241117095301649](/images/2024-11-22/无竞争并发错误.png)

比如图中的程序，线程2设置了一个缓冲区s，然而线程1在第 1059 行释放了同一块内存 s，那么在并发执行的过程中，如果线程1的释放内存先执行，那么在线程2的第142行需要访问缓冲区的时候，就会发生错误。因此，即便是无竞争的并行程序，也可能会发生并发错误。

之前为了检测出潜在的错误，人们通常选择了压力测试，即让目标程序在高负载下持续运行一段时间，并记录下来所有检测到的错误。但是压力测试也存在一些问题，这种形式的测试覆盖范围不足，并且结果难以预测。例如在某些极端情况下，目标程序在一段时间内可能几个bug循环出现，过了一段时间之后其中一个bug被一个新的bug替换掉了，被替换的旧bug可能在接下来很长一段时间都难以出现。

因此，就需要调度程序来确定在不同线程的关键点执行的顺序，即基于调度控制的并发测试（CCT）。CCT通常在目标线程中的关键点(访问共享内存位置或者同步原语的指令)之前插入“调度点”,并以此来控制来自不同线程的这些关键点以不同顺序执行。

![image-20241119194614166](/images/2024-11-22/CCT两个关键点.png)

但是CCT有两个关键点需要注意，第一点，在进行调度控制时，目标程序通常是串行执行，也就是一次执行一个线程，因此目标程序运行到在关键的调度点时，需要由CCT来决定多个线程之间的执行顺序，即是选择继续执行当前的线程，还是利用抢占，休眠延迟，进一步到动态线程优先级修改来进行上下文切换。但是在使用这些调度技术的时候也可能会出现一些问题，例如在关键点前进行休眠延迟时可能会产生一些不可预测的结果并显著减慢执行速度。此外，单纯的串行执行也会引入一些不必要的高开销。

第二个关键点就是怎样合理安排调度去有效探索调度空间，因为随着调度点的增加，调度空间的大小呈几何倍数增长，实际上就是在线程数量很多的情况下，利用穷举法去一个个测试调度策略开销太大，往往不可行。实际上大部分的并发错误的**错误深度都比较小**，错误暴露出来所需的上下文切换次数也比较少。针对这个问题，前人提出了一种抢占式边界计划，提出了计划边界技术，该技术减少了考虑的线程计划的数量，目的是预先保留可能引起错误的计划。抢占式边界限制了计划中允许的抢占式上下文切换的数量。这种保证为可能仍然存在的任何错误的必要复杂性和发生概率提供了一些启发，最近关于并发软件验证的工作采用进度限制来提高可处理性。 

![image-20241117095301649](/images/2024-11-22/错误深度.png)

有工作采用随机测试的方法来探索调度空间，例如PCT,是一种基于随机化的并发测试技术，旨在通过设置线程优先级来触发隐藏的并发错误。PCT通过随机分配线程的优先级，并在程序的执行过程中随机插入线程的优先级切换，从而来探测难以发现的错误。简而言之，PCT强调通过利用少量随机调度事件，来最大化触发深层次并发错误的可能性。这种方式优点在于能够高效地发现深度较大地并发错误，在少量运行下有较高概率触发隐藏错误。但是缺点也很明显，随机性较高，可能导致结果的不确定性。而且随着线程数量增加，错误触发地概率可能降低。通过随机生成调度来测试，**但只能提供发现错误的概率保证**,但是这种算法受制于选择调度点，不易在大程序上使用。此外，PCT一次只运行一个线程，这样会通过序列化执行来破坏并行性，因此，有人提出了PCT算法的并行版本，PPCT。

此外也有工作采用系统化的方法来探索调度空间，例如IPB与IDB，其中IPB是一种基于迭代的调度控制方法，旨在通过限制线程的抢占次数来控制调度空间

![image-20241121092603885](/images/2024-11-22/IPB特性.png)

这种方法的优点在于可以系统性地探索不同抢占模式下的调度空间，并且由于是系统化的探测，可以有效地减少冗余调度，提升测试效率。但是局限性就在于一旦错误的深度过大，对抢占次数的限制可能无法发现某些需要更复杂调度的错误。而且一旦线程数量增多，就需要更多的迭代运行才能覆盖所有场景。

为了对IPB的局限性进行改进，前人提出了IDB，即插入延迟点来探索调度空间。随着运行次数的增加，增加插入的延迟点的数量，从而来逐步扩大调度空间的覆盖范围。这种方式的优势在于，IDB可以灵活选择插入延迟点，可以更全面地覆盖探索空间。但是相对的，由于插入延迟点之后，线程的执行顺序会改变，因此往往需要比深度更多的上下文切换次数来保证覆盖率。

![image-20241117120507055](/images/2024-11-22/常见并发错误检测对比.png)

此外，还有一种利用交错模式，以一种高效和覆盖率有限的方式调度多线程程序的方式，称为Maple。Maple主要是通过静态分析或者预定义交错模式集，确定需要重点覆盖的交错模式，然后再进行调度，执行完毕之后对线程的运行结果进行分析，并更新已覆盖的交错方式，如果存在新的交错模式就记录下来。根据错误信息与覆盖率，调整后续的调度策略。

![image-20241121151516564](/images/2024-11-22/线程交错实例.png)

图中列举了三个变量：lock,waiters,done，两个线程T1和T0并发调用函数once，变量lock在主线程中分配，在子线程中释放，用于保护线程关键区的执行，变量done用来标志线程运行的状态，结束时为1，在一个线程完成关键区之后返回，而waiters表示正在等待的线程数量,在设计时，预期的结果是只有最后一个线程才能够释放lock。

在图中的程序中，可能会出现三个错误，即空指针解引用(NPD)，使用已释放内存(UAF)，双重释放(DF)。其中空指针解引用即线程1已经将LOCK设置为NULL，线程2才要进入关键区。使用已释放内存即线程1释放LOCK之后，线程2才要进入关键区，双重释放即线程1和2都将LOCK释放了一遍。

![image-20241121151516564](/images/2024-11-22/bug.png)

本文提出了一种新的并发测试技术Period，即将线程间的上下文切换通过周期切换自然实现。Period通过一系列的执行周期来管理目标程序的执行，当关键点被分配到某一个执行周期时，只有等上一个周期执行完了才能运行。周期性执行可以通过基于截止日期的任务调度实现，无需抢占和休眠延迟。通过将不同线程的关键点放入执行周期中，就可以实现并行化。

针对上述的两个以前并发测试技术的局限性，在此简述本文Period的核心思想：

![image-20241121101230017](/images/2024-11-22/Period核心思想.png)

![image-20241117151606050](/images/2024-11-22/Period工作流程.png)

上图为Period的工作流程，其中主要由三个方面组成，（1）调度生成器，（2）周期执行器，（3）反馈分析器

调度生成器负责系统性地为目标程序的动态关键点切片（Dynamic Key Point Slice，DKPS）生成调度，并将生成的调度传递给周期执行器。周期执行器按照调度生成器生成的调度，通过周期化执行来控制目标程序的线程交错。同时，周期执行器还负责收集运行时信息，例如错误信息和已激活的关键点切片。而反馈分析器利用历史执行信息来指导调度生成器，有效生成合法的调度，从而覆盖更多尚未测试的线程交错。

<img width="517" alt="周期表示" src="https://github.com/user-attachments/assets/2974c31f-203c-4ca3-a290-faba2176fb3c">

但是实际上调度器仅关心不同线程中的关键点的数量及交错顺序，因此可以将周期中执行的关键点省略，即变为

<img width="160" alt="关键点省略" src="https://github.com/user-attachments/assets/bb45c189-00bd-4e9f-9fd6-28fe76559c24">

接下来第二步就是通过周期执行来进行线程交错。比如上图中生成的调度{T0}{T1}，周期执行后如下图所示。

<img width="582" alt="{T0}{T1}执行结果图" src="https://github.com/user-attachments/assets/2473bcfe-d640-43f0-af92-c077d67ef3e3">


由于线程T0和T1都只占据一个周期，因此T0和T1所有的关键点(图中用金色标出)都应在各自唯一的周期内，即得出新的动态关键点切片
<img width="582" alt="{T0}{T1}执行结果图" src="https://github.com/user-attachments/assets/8df99143-868c-4020-ba76-b9ac61c668a3">

类似的，第二个调度{T1},{T0}的周期执行后如下图
![(T1){T0}执行结果](https://github.com/user-attachments/assets/ac0a8198-0b55-4d0f-b0c3-7e86fe45b118)


如果通过周期执行，发现了一个全新的动态关键点切片，就说明可能还存在其他未被发现的可行调度。因此，为了探索这些未被发现的切片，引入调度前缀的概念，调度前缀的形式为![调度前缀](https://github.com/user-attachments/assets/11367a7c-ebc8-41d7-b35a-4ff40f52bd05)
，比如在上述的s1中，调度前缀就为{T0}。前缀的最后一个周期代表了该周期只能调度来自T0的关键点，同时关键点数量还可以发生变化。

假设周期上限为8，因为两周期的情况已经讨论完，因此拓展到三周期调度进行分析。以s1为例，由于前缀的最后一个周期为T0，因此三周期调度只能为{T0}{T1}{T0}(此处由于周期执行要**线程交错**，因此{T1}之后必须是{T0})，但是在每个周期之内的关键字数量并没有进行限制，因此存在以下几种情况：
<img width="636" alt="三周期情况" src="https://github.com/user-attachments/assets/cb8a7a70-fa49-4c1c-b676-ed702edf496b">


这时发现，在图(f)中出现了一个全新的关键点切片，将这个新的切片记为s3，前缀为{T0*4}{T1}。

在图(g)中，由于T1将LOCK已经释放并且令LOCK为空了，因此若此时再切换到T0利用LOCK进行上锁保护关键区的话，就会出现空指针解引用的错误，此时就通过前缀延伸的方法找出了一个潜在错误。

之后再关于新切片s3进行讨论
![切片s3](https://github.com/user-attachments/assets/c6febec4-887c-40b5-98a3-5f8eac6c265b)

由于三周期调度为{T0*4}{T1}{...}，其中由于线程的交错执行，相邻周期不能是相同的线程，因此三周期已经讨论结束，接下来关于四周期进行讨论，由于前面部分固定为{T0}{T1}{T0},因此四周期的形式必为{T0}{T1}{T0}{T1}，此时范例如上图所示，在s3的基础上，又出现了全新的关键点切片s4，并且前缀为{T0×4}{T1}{T0}，然后再根据s3的形式以此类推：
![切片s4](https://github.com/user-attachments/assets/535fbeb7-ee58-4c63-b9a5-e0496cefd2af)

可以看出左边是使用已释放内存的错误，右边是双重释放的错误，此时已将所有的潜在错误全部找出，这就证明了Period技术的有效性与可行性。通常在使用Period时会设置一个周期上限，避免无休止地增加周期数来测试错误。![动态关键点切片s1](https://github.com/user-attachments/assets/ddb7d47e-7106-47d9-9c7c-0cdcc2cb1c90)

我们将动态关键点切片简称为DKPS，由上可以得知，DKPS[i]即为第i+1个线程执行时遇到的关键字列表。

由于Period将并发程序建模为周期执行，为了保证线程交错执行，令相邻周期不能相同。因此，每个周期的变换都可以看作是一次上下文切换。又因为并发错误的深度为上下文切换的次数，因此并发错误的深度即为周期数-1。又因为大部分并发错误的深度较浅，所以周期数也不会太高，因此设置一个周期数上限，来保证Period的高效性。
![PERIOD算法解释](https://github.com/user-attachments/assets/788eb839-2d9c-4cfd-a064-861e7eba5333)


![PERIOD源码](https://github.com/user-attachments/assets/b7f4d7ea-629d-4a41-bf9e-0f381a094f7e)


![Period规则1](https://github.com/user-attachments/assets/4be71850-9d12-483d-99b0-79ff088c7c77)

根据上述的规则1，假如有五个线程，{T1},{T2},{T3},{T4},{T5}

假设现在有一个深度为2的并发错误，触发的调度顺序为{T1}{T2}{T5}，那么根据上述的调度策略，最坏情况下的周期数为5，即{T1},{T2},{T3},{T4},{T5}，由此可见，虽然这个并发错误的深度为2，但是在最坏情况下，需要执行的周期数为5.

由此可见，如果在周期执行时还是按照串行调度的话，在极端情况下会导致周期数异常增多。因此，就在此引入了并行调度器，即将上述的调度变为{T1}{T2}{T3,T4,T5}，这样探测到深度为2的并发错误所需的周期数就为3，执行完T1,T2之后，会在最后一个周期将其他的全部并行执行一次。但是这样就违背了上述的规则1，最后一个周期包含了来自多个线程的关键点。因此在这里将规则1进行修改，变为：
![PERIOD规则更改之后](https://github.com/user-attachments/assets/2ebbb075-1a4c-4279-9190-1dde59f5b932)


注意，为了保持有序，最后一个周期内线程还是按顺序书写。

同时又因为只是在最后一个周期中并行执行线程，因此在系统地寻找错误时，并不存在遗漏。

在生成调度之后，我们在目标程序中使用周期执行来执行这些调度，并且周期执行需要遵循以下规则：

![image-20241118184459848](/images/2024-11-22/周期规则.png)

![image-20241118190425301](/images/2024-11-22/最后一个周期并发执行示例.png)

周期执行器会收集两个信息，一个是错误信息，即是否触发了错误，第二个是生成的切片，为了更加全面地探索并发错误，要记录下所有生成的切片,并将切片反馈给分析器，由分析器决定是否需要创建新的调度任务。

<img width="255" alt="前缀新生成的调度" src="https://github.com/user-attachments/assets/250ab913-8306-4ab9-986b-fb135b1bc44b">


此处可看出是第五个关键点首先出现了差异，e中是T0，但f中是T1，因此保留前面，再与{T1}进行拼接，即为![新前缀](https://github.com/user-attachments/assets/f69d283f-cba4-491d-a070-8ae41d6565cd)


前缀是为了系统地生成调度，将生成的调度引导向未探索的空间。

4.评估

RQ1： 与串行调度器相比，我们提出的并行调度器在减少调度空间方面的能力如何？
RQ2： 与其他技术相比，Period 在发现并发错误方面的能力如何？
RQ3： Period 带来的运行时开销是多少？

为了评估 Period，我们使用了一组广泛使用的基准测试和真实世界的 CVE，包括来自 SCTBench (一组用来评估并发测试技术的工具)的 36 个程序和来自 CVE 基准  的所有 10 个程序。

这里选择了系统性的技术IPB,IDB,DFS，还有非系统性的技术PCT,Maple,还包含了串行调度器，即Period的串行调度，这里称为Serial

![image-20241119154313799](/images/2024-11-22/CVE下错误检测能力对比.png)

![image-20241119154326673](/images/2024-11-22/SctBench下错误检测方法对比.png)

在图2中，我们设置错误的深度上限为3

从上述图2中蓝色部分可以看出，在3线程，4线程与5线程的情况下，Period的调度数为27，100，225，而Serial的调度数为30，384，5040，可以看出Serial需要更大的调度空间，而且在错误深度为d的情况下，Period的调度数不超过d+1，在10线程的情况下，Period的调度数也仅为2350；而且对比两者的参数，从左到右为首先检测到错误所需的调度数量，探索的调度总数，错误调度总数，经过对比之后发现，Period比Serial多检测出了8个并发错误，由此可以看出，并行调度的开销更小，速度更快，检测BUG的遗漏相比于串行调度也要更少。

这个错误需要5次上下文切换，而在图二中设置的错误深度上限为3，因此检测不到。

![image-20241119164205027](/images/2024-11-22/调度数与发现BUG数的关系图.png)

横坐标是总调度数，纵坐标是发现的BUG数量，当调度数越少，发现的BUG数量越多时，效率越高，因此当图线的增长率较高时，开销较小，因此由图可知，Period是最高效的。

![image-20241119164205027](/images/2024-11-22/平均执行速度.png)

上述实验表明，Period在发现并发错误方面是有效且高效的，此外，在20个开源的程序中，Period成功识别了5个以前从未发现过的错误，

由于并发测试难以捕捉，受控并发测试一直是广泛研究的课题，Chess展示了迭代抢占边界（IPB）的有效性，然后又提出了迭代延迟边界（IDB），用于发现多线程软件中的错误。PCT以及改进后的并行化版本PPCT都是通过设置线程优先级来控制底层操作系统或运行时的调度，展示了随机调度的能力和有效性。RPro提出了一种基于半径感知的概率测试方法，通过在目标死锁的半径内选择优先级变化点来触发死锁，而不是在所有事件中选择。TSVD则是动态识别潜在的线程安全问题并注入延迟，以引导程序进入不安全状态。

Period通过一种较为新颖的周期性执行来实现受控调度，支持非抢占性并允许并行化（最后一个周期），并通过调度前缀系统地探索每个DKPS地调度空间。

此外，在开头提到并发错误不仅受到线程交错执行顺序的影响，还会受到输入的影响。因此还有许多技术利用模糊测试（通过自动化工具来生成随机或者为随机的异常测试数据）来生成测试输入，从而揭发并发程序中的错误。
